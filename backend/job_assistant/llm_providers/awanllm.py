"""
TODO: clean file header description
Handles Awan LLM Api calls

Documentation: https://www.awanllm.com/docs
"""

import logging
import re
import requests
import json
import tiktoken

from job_assistant.constants import (
    AWANLLM_SECRET_KEY,
)

######################## LOGGING CONFIGURATION ########################
LOGGER = logging.getLogger(__name__)
AWANLLM_API = "https://api.awanllm.com/v1/chat/completions"
MODEL = "Meta-Llama-3-8B-Instruct"
ROLE = "assistant"
HEADERS = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {AWANLLM_SECRET_KEY}",
}


######################## TEXT PROCESSING UTILITIES ########################
def get_response(prompt: str) -> str:
    """
    Get response from an AI model based on the provided prompt.

    Args:
        prompt (str): The prompt to be sent to the AI model.

    Returns:
        str: The response generated by the AI model.
    """
    payload = json.dumps(
        {"model": MODEL, "messages": [{"role": ROLE, "content": prompt}]}
    )

    response = requests.post(AWANLLM_API, headers=HEADERS, data=payload)
    json_data = response.json()
    clear_text = json_data["choices"][0]["message"]["content"]

    return clear_text


def count_tokens(text: str) -> int:
    """Calculates the number of tokens in a given text string using the provided tokenizer."""
    encoding = tiktoken.get_encoding("cl100k_base")
    num_tokens = len(encoding.encode(text))
    return num_tokens


def summarize_resume(keywords: str) -> dict:
    """
    Summarizes a resume by sending a request to an API.

    Args:
        keywords (str): Text extracted from resume.

    Returns:
        dict: Extracted information from the resume in JSON format.
    """

    template = f"""
    As a smart recruiter assistant specialized in CV analysis.
    1) Analyse the following CV of an applicant
    2) Extract the most relevant skills, experience and education.
    4) Ignore all unnecessary details (e.g: phone number, email address, birthday)

    Extracted applicant information from its CV:
    {keywords}

    ---
    Do NOT explain your thinking process. Do not add additional informations and details
    Answer MUST be a Json format matching this template:
    {{
        "skills": {{
            "hard": [dev stack and technologies used],
            "soft": []
        }},
        "experience": {{
            "pro": [
                "experience1": [very brief list of tasks],
                ...,
                "experienceN": [very brief list of tasks]
            ],
            "perso": [
                "experience1": [very brief list of tasks],
                ...,
                "experienceN": [very brief list of tasks]
            ]
        }},
        "education": {{
            "university": "",
            "degrees": []
        }}
    }}
    """
    try:
        clear_text = get_response(template)

        pattern = r"```(.*?)```"
        matches = re.findall(pattern, clear_text, re.DOTALL)

        if matches:
            user_data = json.loads(matches[0])
        else:
            json_text = clear_text.split("JSON format:", 1)[-1].strip()
            user_data = json.loads(json_text)

        return user_data

    except json.JSONDecodeError as e:
        error_message = f"The AI failed to return a proper JSON format while summarizing resume. \
            Input token count: {count_tokens(template)}, Output token count: {count_tokens(clear_text)}. Error: {str(e)}"
        LOGGER.critical(error_message)
        raise json.JSONDecodeError(error_message, doc=clear_text, pos=0)

    except Exception as e:
        error_message = f"Error summarizing resume. Input token count: {count_tokens(template)}, \
            Output token count: {count_tokens(clear_text)}. Error: {str(e)}"
        LOGGER.error(error_message)
        raise Exception(error_message)


def match_applicant_to_job(job_title: str, extracted_data: dict, job_description: str):
    """
    Matches the applicant's skills to the job requirements and provides a matching score.

    Args:
        job_title (str): The title of the job.
        extracted_data (dict): Summary of skills and experience extracted from the applicant's CV.
        job_description (str): Description of the job including required skills and experience.

    Returns:
        dict: A dictionary containing the matching score and a comment.

    Raises:
        ValueError: If the input data is invalid.
        JSONDecodeError: If the API response is not in proper JSON format.
        Exception: For other unexpected errors.
    """
    template = f"""
    As a smart recruiter assistant from a tech company.
    1) Analyse if the summary of skills of the applicant matches the job requirements.
    2) Provide a score from 0 to 100% based on the match.
    3) Add a brief explanation of the match if you think the applicant has little chance to be selected.
    4) Ignore everything related to job description that is not about skills and experience to accurately match the applicant.

    Applicant information summary:
    {extracted_data}

    Job title:
    {job_title}

    Job description:
    {job_description}

    ---
    Do NOT explain your thinking process. Do not add additional information and details
    Answer MUST be a JSON format matching this template:
    {{
        "match": int,
        "comment": ""
    }}
    """
    try:
        clear_text = get_response(template)
        LOGGER.debug("Response from API: %s", clear_text)

        pattern = r"```(.*?)```"
        matches = re.findall(pattern, clear_text, re.DOTALL)

        if matches:
            match_result = json.loads(matches[0])
        else:
            json_text = clear_text.split("JSON format:", 1)[-1].strip()
            match_result = json.loads(json_text)

        return match_result

    except json.JSONDecodeError as e:
        error_message = f"The AI failed to return a proper JSON format while match_applicant_to_job. \
            Input token count: {count_tokens(template)}, Output token count: {count_tokens(clear_text)}. Error: {str(e)}"
        LOGGER.critical(error_message)
        raise json.JSONDecodeError(error_message, doc=clear_text, pos=0)

    except Exception as e:
        error_message = f"Error match_applicant_to_job. Input token count: {count_tokens(template)}, \
            Output token count: {count_tokens(clear_text)}. Error: {str(e)}"
        LOGGER.error(error_message)
        raise Exception(error_message)
